
! 코딩지식

@ 의존성 주입

A클래스 내부에서 B클래스를 멤버변수로 쓸때, B클래스를 A클래스 내부에서
생성하는게 아니라, 생성자의 인자나 함수의 인자로 받아서 셋팅해주는것.

이게 왜 의존성을 해결한 것이냐?

class Programmer {
    private Coffee coffee;

    public Programmer() {
	//만약 Coffee가 변경되면 Programmer도 변경되어야 할 수 있다.
    	this.coffee = new Coffee(); 
    }
    
    public startProgramming() {
    	this.coffee.drink(); // 일단 마시고 시작하자
        ...
    }
}

의존성 주입은 이런 경우를 방지할 수 있다.

class Programmer {
    private Coffee coffee;

    // 그 날 마실 커피를 고를 수 있게된 개발자
    public Programmer(Coffee coffee) {
    	this.coffee = coffee;
    }
    
    public startProgramming() {
    	this.coffee.drink();
        ...
    }
}



! 코틀린

세미콜론이 없음.
val은 상수
var은 변수
선언만 할 경우에는 
var e : String 처럼 타입을 명시해주어야함. (기본적으로 추론)

1. String 탬플릿
printf("my name is ${name}I'm 23"); // {}를 안써줘도 되지만 만약 $namei'm처럼 되면 변수 인식을 못함.
웬만하면 대괄호 쓰자.
prinf("is this true? ${1==0}");
$가 문자일 경우, printf("this is 2\$a");

2. 함수 축약

fun maxBy(a : Int, b: Int) : Int { 
	if(a>b)
	return a
	else
	return b

}

fun maxBy2(a : Int, b : Int) : Int = if(a>b) return a else b;

3. 스위치 == when

fun checkNum(scroe : Int) {
	when(scroe) {
		0 -> println("this is 0")
  		1 -> println("this is 1")
		2,3 -> println("this is 2 or 3")
		else -> println("i don't know")
	//리턴도 가능
	var b = when(scroe){
	1 ->1
	2 ->2
	else 3 // else는 항상 써야함.
}

	when(scroe){
	 in 90..100 -> println("good") //90~100일때 

4. Expression vs Statement

Expression 은 값을 반환하는 것. java 의 경우에는 void 리턴함수. 코틀린은 모든 함수(리턴값이 없어도 Unit을 리턴함)
Statement ~~해라 명령.

5. Array and List

Array는 정적배열, mutable함.


fun array() {
 val array = arrayof(1,2,3)
 val list = listOf(1,2,3)

val array2 = array(1,"d",3,4)
val list2 = listOf(1,"d",123)
 
}



List는 

1. List (수정불가) 읽기전용. 안의 원소를 못바꿈
val list = listOf(1,2,3)
list[0] = 10 //불가
var result = list.get(0) //인덱스 접근도 가능.


2. MutableList 


val arraylist = arrayListOf<Int>()  //val 
arratlist.add(10)

6. For

var sum : Int = 0
for ( i in 1..10 step 2) {  // 1 ~ 10 중에 1,3,5,7,9 를 순회
 sum += i
}
println(sum)

for(i in 10 downTo 1) { // 10부터 1까지 내려감
}

for(i in 1 until 100) // 1..100(1,100포함) 과 다른점은 1~99까지 돈다는것, (1,99포함)

}

val student = arrayListOf("joyce", "james");
for((index, name) in student.withIndex()); //인덱스, 문자열 pair로 순회

7. nullable / nonNull

nallable은 ?를 붙인다.

var nullName : String? = null // nullable은 암묵적으로 타입추정이 안되기때문에 명시적으로 써줘야한다.

var nullNameInUpperCase = nullName?.toUpperCase() // nullName이 null이 아니라면 대문자로 바꿔라.


8. 엘비스 연산자 ?:  누운 엘비스머리 같다해서 엘비스 연산자.

val lastName : String? = null
val fullName : String = name + "" + (lastname?: "No lastname") //lastname이 널이아니면 lastname. 널이면 
						      //no lastname. 삼항연산자 느낌.

9. as?

 val value: Int = animal as? Int ?: 0  //as는 캐스팅인듯. as?는 Int로 변환가능하면 animal이 int로 변환된 값이 value
				// 불가능이면 0

10 !! 널값보증연산자

fun nonNull()
{
 val animal :String? = "호랑이"
 val animalName = animal!! //animal은 절대 null값이 아니다라고 컴파일러에게 알려줌.
			// null이면 오류남.


11. let. 어떤 변수를 람다식 안으로 캡쳐

val padding = TypedValue.applyDimension(
        TypedValue.COMPLEX_UNIT_DIP, 16f, resources.displayMetrics).toInt()
// 왼쪽, 오른쪽 padding 설정
setPadding(padding, 0, padding, 0)

padding은 setPadding에서만 사용하는 상수이기 때문에 변수선언이 불필요하다.
따라서

TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 16f,
        resources.displayMetrics).toInt().let { padding ->
    // 계산된 값을 padding 이라는 이름의 인자로 받음
    setPadding(padding, 0, padding, 0)
}

요렇게 가능.
람다식의 인자가 한 개일 경우, 인자 이름을 생략하고 it을 사용하여 코드 간결화도 가능.


12. Class

- 생성자

class Human constructor(name : String = "minsu"){ //생성자에 디폴트 매개변수 가능

 val name : String = name

 fun eatingCake() { println("this is ${name}")}
}

위코드는 이렇게 생략가능

class Human (name : String = "minsu"){ //생성자에 디폴트 매개변수 가능


 fun eatingCake() { println("this is ${name}")}
}


//생성자에서 초기화작업은 init에서 하면 됨
//생성자 오버로딩은 부생성자에서 하면 됨

class Human (name : String = "minsu"){ //주 생성자. 생성자에 디폴트 매개변수 가능

//this(name)은 주생성자에 name을 넘기는 역할
 constructor(name : String, arg : Int) : this(name) {println("my name is ${name}, age is ${age} }


 //주생성자의 일부
 init{
 println("new Human born")}

 fun eatingCake() { println("this is ${name}")}
}

  
}

의문
1. 주생성자(primary constructor)에 꼭 name을 넘겨야함??  넘겨야함. 부생성자는 주생성자를 상속받는 개념이기 때문에.
주생성자가 기본생성자면 되지뭐..
2. init이 주생성자여서 부생성자(secondary constructor)보다 init이 먼저 불린다는데..? 
정확히는 
 constructor(name : String, arg : Int) : this(name)  이부분에서
부모의 생성자를 부르니까 주생성자의 init이 불리는거임.
만약 주생성자를 작성하지않고 (기본생성자이고) 부생성자에서
this()를 하지 않아도 암묵적으로 불리기 때문에 주생성자의 init은 항상
부생성자의 초기화블록보다 더 먼저 불림.


생성자 호출순서

class InitOrderDemo(name: String) {
    val firstProperty = "First property: $name".also(::println)
    
    init {
        println("First initializer block that prints ${name}")
    }
    
    val secondProperty = "Second property: ${name.length}".also(::println)
    
    init {
        println("Second initializer block that prints ${name.length}")
    }
}



First property: hello
First initializer block that prints hello
Second property: 5
Second initializer block that prints 5
*****************************************************


class Customer(name: String) {
   //프로퍼티 이니셜라이저에서 사용가능
    val customerKey = name.toUpperCase()
}

*******************************************

// val이나 var을 붙이면 생성자의 매개변수들은 곧바로 필드가 된다.
class Person(val firstName: String, val lastName: String, var age: Int) { /*...*/ }


https://kotlinlang.org/docs/reference/classes.html


13. 프로퍼티

프로퍼티는 클래스 멤버변수(필드) + 게터세터를 말함.
코틀린의 클래스 멤버변수는 모두 프로퍼티다.
모든 멤버변수는 안보여도 getter, setter를 default로 가지고있고,
디폴트 getter는 그냥 대입, 디폴트 setter는 그냥 셋팅인듯.
커스텀가능

var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // parses the string and assigns values to other properties
    }	


만약 set만 private으로 만들고싶다면,

var setterVisibility: String = "abc"
 private set // the setter is private and has the default implementation

이렇게 하면 됨.

배킹필드는 field라는 예약어로 지원함

var counter = 0 // Note: the initializer assigns the backing field directly
    set(value) {
        if (value >= 0) field = value
    }


field 가 진짜 멤버변수고  counter는 프로퍼티


13. Lamda

기본형
val lamda : Type = {argumentList -> codebody}

val square : Int ={number : Int -> number * number}
val square = {number : Int -> number * number}
 
 




@ 상속
* 코틀린의 모든 클래스는 기본 final임. 따라서 부모클래스에 open 키워드를 붙여야 상속가능
   함수도 오버라이딩하면 open 붙은거만 가능.

open class Human()
{
 open fun sing(){}
}

class Korean : Human(){	

 override fun sing() { println("sdad")}

 }


@ 그래들, 메이븐, cmake
빌드툴.
모두 빌드 자동화툴이다.
그래들이 제일 낫다??


@ val 은 valuable(귀중한, 가치있는)
   var은 variable (가변적인)


@ 자바의 fuctional Interface(함수 하나만있는 인터페이스) 는
람다식의 타겟타입이 될 수 있다.
@FunctionalInterface
public interface MyFunctionalInterface {
    public void method();
}

 public static void main(String[] args) {
        MyFunctionalInterface fi;
        fi = () -> {
            String str = "hello lamda!";
            System.out.println(str);
        };
        fi.method();

        fi = () -> System.out.println("hello again!");
        fi.method();

    }

이를 코틀린에서는


MyFunctionalInterface fi = {} 이렇게 쓸수 있으므로

@ data 클래스

보일러플레이트를 줄여줌.

equals()/hashCode() pair;
toString() of the form "User(name=John, age=42)";
componentN() functions corresponding to the properties in their order of declaration;
copy() function (see below).

를 자동으로 만들어줌
여기서 Copy 는 객체 복사시에 특정 프로퍼티만 수정해서 복사하고싶을때 씀

copy구현체
fun copy(name: String = this.name, age: Int = this.age) = User(name, age)

사용
val jack = User(name = "Jack", age = 1)
val olderJack = jack.copy(age = 2)

val human = DataClass("manta", 0, 27)
val olderMan = human.copy(age = 28);
    


@ evaluate의 의미

When a statement is executed then it comes to the action of evaluation of its expressions. First execution takes place and then evaluation.

In the snippet

int i = 5, j;
j = 10 + 5*i;
when the statement j = 10 + 5*i; is executed then evaluation of expressions j, 10, 5*i, 10 + 5*i and j = 10 + 5*i takes place. Note that first three can be evaluated in any order.

@ object

object는 싱글톤클래스다.
static의 사용은 프로젝트가 커지면 커질수록 버그를 야기한다.
(여러 인스턴스에서 수정가능)
따라서 static을 안쓰고 object라는 싱글톤 클래스안에 static한 필드나 메소드를
모아둠으로써 관리하기 편하게 만들었다.


companion object는 class 안에 정의되어
클래스와 동반자 오브젝트인 셈이다.
즉, 클래스 하위의 static한 필드, 메소드들을 모아둔 것.
이 또한 클래스가 메모리에 적재될때 생성된다.

static 과 싱글톤의 차이
static은 메모리에 적재될때 생성되고
싱글톤은 getInstance 시에 생성됨.

싱글톤에 생성자가 없는 이유
생성자는 객체마다 차이를 주기 위해 존재.
싱글톤은 오직 하나의 객체이기 때문에 필요없음.
대신 object의 경우, 초기화가 필요하다면 init블록을 활용가능.

https://medium.com/@BladeCoder/kotlin-singletons-with-argument-194ef06edd9e


 abstract  class animal(var name : String)
 {
     //코틀린은 null-safe하다. 모든건 선언과 동시에 초기화해야한다.
     //var a : Int  불가
     //하지만 의존성주입이나 설계상 필요시 선언만 해야할 때도 있다. 그럴때는 lateinit을 붙인다.
     lateinit var a : TestClass
     //lateinit  var a : Int 불가 // 원시타입은 불가능하다.

     abstract fun bark()
 }

interface  entity
{
    fun bark()
}

fun createAnimal()
{
    //자바에서 funtional interface를 통해 생성하던 익명클래스, 익명객체를 object를 이용해 구현할 수 있다.
    val A : animal = object : animal("dog") {
        override fun bark() {
           println("멍멍")
        }
    }

    val B : entity = object : entity{
    override fun bark(){
        println("꽥꽥")
    }

}


! 안드로이드 스튜디오

1. scaleType : 이미지의 크기를 ImageView 영역어 어떻게 맞출지에 대한 속성



<ImageButton
    android:id="@+id/btn_back"
    android:layout_width="wrap_content"
    android:layout_height="wrap_content"
    android:background="#00000000"
    android:src="@drawable/btn_back"
    android:scaleType="centerInside" //이 부분
 />







MATRIX = 원본 크기 그대로 보여줌 (왼쪽상단 정렬) 
CENTER = 원본 크기 그대로 보여줌 (가운데 정렬)
CENTER_CROP = View 영역에 공백이 있으면 채워서 보여줌(비율유지)
CENTER_INSIDE = View 영역을 벗어나면 맞춰서 보여줌(비율유지)
FIT_START = View 영역에 맞게 보여줌 (왼쪽상단 정렬, 비율유지)
FIT_CENTER = View 영역에 맞게 보여줌 (가운데 정렬, 비율유지)
FIT_END = View 영역에 맞게 보여줌 (왼쪽하단 정렬, 비율유지)
FIT_XY = View 영역을 가득 채워서 보여줌(비율유지 안함)